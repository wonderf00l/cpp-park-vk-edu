если передаём по указателю: непонятно, что с владением(временное пользование или сущность получает полное владение ресурсом)

утечки памяти

копирование объектов + при работе с полиморфными классами(напр возвращение BaseFile вместо BaseFile*) вернёт именно копию объекта класса BaseFile, а не потомка, которого могли бы получить в результате работы функции

лишние копирования: если внутри функции создаётся временный объект, который все равно погибнет, то приходится делать лишнее копирование при возвращении копии из функции и просвоения ее какой-либо переменной

DataHolder
меняем местами проинициализироварные данные v с default проинициализированными данными data

rvalue объекты можно передавать только по const ссылке
с c++11 rvalue значения можно передавать по rvalue ссылкам

rvalue ссылки - ссылки на временные объекты

выражение в c++:
характеризуется типом(int, int*, int& etc) и категорией значения (lvalue, rvalue, prvalue etc)
int&& int_ref = 10;
int_ref - тип rval ref на integer, значение - lvalue(обладает адресом)
10 - тип int, значение rval int